## (一) 操作系统接口
### 1.操作系统的工作:
- (1)将计算机的资源在多个程序间共享，并且给程序提供一系列比硬件本身更有用的服务;
- (2)管理并抽象底层硬件.

操作系统通过**接口**向用户程序提供服务.

xv6 使用了传统的内核概念 - 一个向其他运行中程序提供服务的特殊程序。每一个运行中程序（称之为进程）都拥有包含指令、数据、栈的内存空间。指令实现了程序的运算，数据是用于运算过程的变量，栈管理了程序的过程调用.


进程通过系统调用使用内核服务。系统调用会进入内核，让内核执行服务然后返回。所以进程总是在用户空间和内核空间之间**交替运行**。

内核提供的一系列系统调用就是用户程序可见的操作系统接口.这些接口,就是一些 API,程序员可以调用它们.它们永远运行在内核态,内核态的安全性由硬件电路保证.内核使用了 CPU 的硬件保护机制来保证用户进程只能访问自己的内存空间.

## (二) 进程和内存
一个 xv6 进程由两部分组成:
- 一部分是用户内存空间（指令，数据，栈）;
- 是仅对内核可见的进程状态.

xv6 提供了**分时特性**：它在可用 CPU 之间不断切换，决定哪一个等待中的进程被执行。当一个进程不在执行时，xv6 保存它的 CPU 寄存器，当他们再次被执行时恢复这些寄存器的值。内核将每个进程和一个 pid (process identifier) 关联起来.

父子进程拥有不同的内存空间和寄存器，改变一个进程中的变量不会影响另一个进程。

系统调用 exec 将从某个文件（通常是可执行文件）里读取内存镜像，并将其替换到调用它的进程的内存空间。这份文件必须符合**特定的格式**，规定文件的哪一部分是指令，哪一部分是数据，哪里是指令的开始等等。xv6 使用 ELF 文件格式.

xv6 shell 用以上调用为用户执行程序。shell 的主要结构很简单，详见 main 的代码（8001）。主循环通过 getcmd 读取命令行的输入，然后它调用 fork 生成一个 shell 进程的副本。父 shell 调用 wait，而子进程执行用户命令。举例来说，用户在命令行输入“echo hello”，getcmd 会以 echo hello 为参数调用 runcmd（7906）, 由 runcmd 执行实际的命令。对于 echo hello, runcmd 将调用 exec 。如果 exec 成功被调用，子进程就会转而去执行 echo 程序里的指令。在某个时刻 echo 会调用 exit，这会使得其父进程从 wait 返回。你可能会疑惑为什么 fork 和 exec 为什么没有被合并成一个调用，我们之后将会发现，将创建进程——加载程序分为两个过程是一个非常机智的设计。

![Alt text](image-1.png)

xv6 通常隐式地分配用户的内存空间。fork 在子进程需要装入父进程的内存拷贝时分配空间，exec 在需要装入可执行文件时分配空间。一个进程在需要额外内存时可以通过调用 sbrk(n) 来增加 n 字节的数据内存。 sbrk 返回新的内存的地址.

## (三) I/O 和文件描述符

万物皆文件.

文件描述符是一个整数，它代表了一个进程可以读写的被内核管理的对象。进程可以通过多种方式获得一个文件描述符，如打开文件、目录、设备，或者创建一个管道（pipe），或者复制已经存在的文件描述符。简单起见，我们常常把文件描述符指向的对象称为“文件”。文件描述符的接口是对文件、管道、设备等的抽象，这种**抽象使得它们看上去就是字节流**。

每个进程都有一张表，而 xv6 内核就以文件描述符作为这张表的索引，所以每个进程都有一个从0开始的文件描述符空间。按照惯例，进程从文件描述符0读入（标准输入），从文件描述符1输出（标准输出），从文件描述符2输出错误（标准错误输出）。我们会看到 shell 正是利用了这种惯例来实现 I/O 重定向。shell 保证在任何时候都有3个打开的文件描述符（8007），他们是控制台（console）的默认文件描述符.

系统调用 close 会释放一个文件描述符，使得它未来可以被 open, pipe, dup 等调用重用。一个新分配的文件描述符永远都是当前进程的最小的未被使用的文件描述符.

文件描述符和 fork 的交叉使用使得 I/O 重定向能够轻易实现。fork 会复制父进程的文件描述符和内存，所以子进程和父进程的文件描述符一模一样。exec 会替换调用它的进程的内存但是会保留它的文件描述符表。这种行为使得 shell 可以这样实现重定向：fork 一个进程，重新打开指定文件的文件描述符，然后执行新的程序。

子进程关闭文件描述符0后，我们可以保证open 会使用0作为新打开的文件 input.txt的文件描述符（因为0是 open 执行时的最小可用文件描述符）。之后 cat 就会在标准输入指向 input.txt 的情况下运行。

xv6 的 shell 正是这样实现 I/O 重定位的（7930）。在 shell 的代码中，记得这时 fork 出了子进程，在子进程中 runcmd 会调用 exec 加载新的程序。现在你应该很清楚为何 fork 和 exec 是单独的两种系统调用了吧。这种区分使得 shell 可以在子进程执行指定程序之前对子进程进行修改.

```c
int main() {
    int pid = fork();
    if (pid == 0) {
        write(1, "hello ", 6);
    } else {
        int status;
        wait(&status);
        write(1, "world\n", 6);
    }
    return 0;
}
```


```c
fd = dup(1);
write(1, "hello", 6);
write(fd, "world\n", 6);
```



dup 复制一个已有的文件描述符，返回一个指向同一个输入/输出对象的新描述符。这两个描述符共享一个文件偏移，正如被 fork 复制的文件描述符一样.

值得注意的是:从同一个原初文件描述符通过一系列 fork 和 dup 调用产生的文件描述符都共享同一个文件偏移，而其他情况下产生的文件描述符就不是这样了，即使他们打开的都是同一份文件.

## (四) 管道

管道是一个小的内核缓冲区，它以文件描述符对的形式提供给进程，一个用于写操作，一个用于读操作。从管道的一端写的数据可以从管道的另一端读取。管道提供了一种进程间交互的方式.

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main() {
    int p[2];
    char *argv[2];
    argv[0] = "wc";
    argv[1] = 0;
    // 创建一个新的管道并且将读写描述符记录在数组 p 中
    pipe(p);
    if (fork() == 0) {
        close(0);
        dup(p[0]);
        close(p[0]);
        close(p[1]);
        execl("/bin/wc", argv);
    } else {
        write(p[1], "hello world\n", 12);
        close(p[0]);
        close(p[1]);
    }
    return 0;
}
```
`dup(p[0])` 是用于重定向标准输入的操作。下面我将详细解释这个操作的细节：

1. `p[0]` 是管道的读取端文件描述符，它允许从管道中读取数据。

2. `dup(p[0])` 是一个系统调用，用于复制文件描述符。具体来说，它会将文件描述符 `p[0]` 复制到当前进程中可用的最小文件描述符号码，通常是 0（标准输入文件描述符）。

3. 这意味着，在执行 `dup(p[0])` 后，标准输入文件描述符 0 将指向与 `p[0]` 相同的管道读取端。这就实现了标准输入的重定向，使得从标准输入读取数据的操作实际上是从管道中读取数据。

4. 在子进程中，`close(0)` 用于关闭原始的标准输入文件描述符，因为它已经被 `dup(p[0])` 重定向到了管道。

总之，`dup(p[0])` 操作的细节是将标准输入重定向到了管道的读取端，从而使子进程可以从管道读取数据，而不是从键盘或其他标准输入源读取数据。这是一种常见的管道和进程通信的方式，它允许父进程向子进程发送数据，子进程则可以像从标准输入读取一样读取这些数据。

对这段代码的解释:

- 在子进程中：close(0);：关闭标准输入文件描述符（0）。
dup(p[0]);：将标准输入重定向到管道的读取端，这样子进程将从管道读取数据。
close(p[0]);：关闭管道的读取端，因为标准输入已经重定向到了管道。
close(p[1]);：关闭管道的写入端，因为子进程不会写入管道。
然后，子进程调用 execl("/usr/bin/wc", "wc", (char *)0); 来执行 /usr/bin/wc 命令，同时传递了参数 "wc"。

- 在父进程中：write(p[1], "hello world\n", 12);：向管道的写入端写入 "hello world\n"，这将被子进程的 wc 命令读取和处理。
close(p[0]);：关闭管道的读取端，因为父进程不会从管道读取数据。
close(p[1]);：关闭管道的写入端，因为数据已经写入管道。
这段代码的目的是演示如何使用管道和 fork 创建一个父子进程通信的示例。子进程执行 wc 命令并统计传递给它的文本的字数，而父进程通过管道将数据传递给子进程，然后关闭管道的两个端口。请注意，子进程会等待标准输入中的数据，然后计算字数，最后在标准输出中打印结果。

如果数据没有准备好，那么对管道执行的read会一直等待，直到有数据了或者其他绑定在这个管道写端口的描述符都已经关闭了。在后一种情况中，read 会返回 0，就像是一份文件读到了最后。读操作会一直阻塞直到不可能再有新数据到来了，这就是为什么我们在执行 wc 之前要关闭子进程的写端口。如果 wc 指向了一个管道的写端口，那么 wc 就永远看不到 eof 了。

## (五) 文件系统

xv6 文件系统提供文件和目录:
- 文件就是一个简单的字节数组;
- 目录包含指向文件和其他目录的引用.

xv6 关于文件系统的操作都被实现为用户程序，诸如 mkdir，ln，rm 等等。这种设计允许任何人都可以通过用户命令拓展 shell 。现在看起来这种设计是很显然的，但是 Unix 时代的其他系统的设计都将这样的命令内置在了 shell 中，而 shell 又是内置在内核中的。

有一个例外，那就是 cd，它是在 shell 中实现的（8016）。cd 必须改变 shell 自身的当前工作目录。如果 cd 作为一个普通命令执行，那么 shell 就会 fork 一个子进程，而子进程会运行 cd，cd 只会改变子进程的当前工作目录。父进程的工作目录保持原样.

## (六) 现实情况

UNIX 将“标准”的文件描述符，管道，和便于操作它们的 shell 命令整合在一起，这是编写通用、可重用程序的重大进步。这个想法激发了 UNIX 强大和流行的“软件工具”文化，而且 shell 也是首个所谓的“脚本语言”。UNIX 的系统调用接口在今天仍然存在于许多操作系统中，诸如 BSD，Linux，以及 Mac OS X。

现代内核提供了比 xv6 要多的多的系统调用和内核服务。最重要的一点，现代基于 Unix 的操作系统并不遵循早期 Unix 将设备暴露为特殊文件的设计，比如刚才所说的控制台文件。Unix 的作者继续打造Plan 9 项目，它将“资源是文件”的概念应用到现代设备上，将网络、图形和其他资源都视作文件或者文件树.

